<%
  require 'lib/rumai/nfo'

  # local variables for this document
  download_url    = 'http://rubyforge.org/frs/?group_id=5005'
  source_repo_url = File.join(Rumai::NFO[:website], 'src')
  feed_url        = File.join(Rumai::NFO[:website], 'news.xml')

  ruby_url        = 'http://ruby-lang.org'
  wmii_url        = 'http://www.suckless.org/wiki/wmii'
  wmii_ixp_url    = 'http://www.suckless.org/wiki/libs/libixp'
  p9p_url         = 'http://cm.bell-labs.com/magic/man2html/5/intro'

  # parameters for the HTML format
  $title   = "#{Rumai::NFO} user guide"
  $authors = { 'Suraj N. Kurapati' => 'http://snk.tuxfamily.org' }
  $feeds   = { feed_url => :rss }

  # parameters for Gerbil
  $unindent = '  '
%>

<% chapter "Introduction" do %>
  Rumai is a library for manipulating the "wmii":<%= wmii_url %> window manager through "Ruby":<%= ruby_url %>. It excels at *dynamic arrangement* of clients, columns, views, and tags.

  Rumai also provides (1) an <%= xref 'shell', 'interactive shell' %> for live entertainment, and (2) a *pure Ruby client* for the "9P2000 protocol":<%= p9p_url %>, which it uses to communicate with wmii's "IXP file-system interface":<%= wmii_ixp_url %>.

  Rumai is *open-source software* (see <%= xref "License" %>) so feel free to contribute your improvements to and discuss your ideas with the author. You can obtain the source code from the project "Darcs":http://darcs.net repository by running the following command:

    darcs get <%= source_repo_url %> rumai

  <% section "Resources" do %>
    * "News feed":<%= feed_url %>
      - project news and release announcements.
    * "Download area":<%= download_url %>
      - place to obtain release packages.
    * "API reference":api/index.html
      - documentation for all provided Ruby code.
    * Support / feedback
      - send an e-mail to the author (see address in <%= xref "License" %>).
  <% end %>

  <% section "License" do %>
    <%=h File.read('LICENSE') %>
  <% end %>
<% end %>

<% chapter "Setup" do %>
  <% section "Requirements" do %>
    Your system needs the following software to run Rumai.

    |_. Software |_. Notes |
    | "Ruby":<%= ruby_url %> | Version 1.8.x is required. |
    | "wmii":<%= wmii_url %> | Version 3.6 or newer is required. |
  <% end %>

  <% section "Installation" do %>
    If your system has "RubyGems":http://rubygems.org/, then you can install Rumai by running the following commands:

      gem install rumai
      rumai -v

    Otherwise, follow these instructions:
    # Download the newest release package from "the download area":<%= download_url %>.
    # Extract the release package anywhere you want on your system.
    # Go inside the extracted directory and run the following command:

      ruby bin/rumai -v

    If the installation was successful, then you will see output like this: <pre><%=h `ruby bin/rumai -v` %></pre>

    Otherwise, you can e-mail the author (see address in <%= xref "License" %>) for help.
  <% end %>

  <% section "Manifest" do %>
    Now that Rumai is installed on your system, let us examine its installation directory.
    * If you installed Rumai manually, then you already know the location of its installation directory.
    * If you installed Rumai using RubyGems, then run <pre>rumai -v</pre> and select the right-most item in the output--that is the path of Rumai's installation directory.

    Inside Rumai's installation directory, you will see (among other things) the following items:
    * <tt>bin/</tt> - contains executable programs.
    ** <tt>rumai</tt> - the interactive shell.
    * <tt>lib/</tt>
    ** <tt>rumai.rb</tt> - the main Rumai library.
    ** <tt>rumai/</tt>
    *** <tt>ixp.rb</tt> - the pure Ruby client for the "9P2000 protocol":<%= p9p_url %>.
    * <tt>doc/</tt> - contains the user guide and other documentation.
    ** <tt>guide.erb</tt> - the source file of this user guide.
    ** <tt>api/</tt> - contains API reference documentation.
    * <tt>LICENSE</tt> - the project license and copyright notice.
  <% end %>

  <% section 'Version numbering system' do %>
    Rumai uses the "RubyGems rational versioning policy":http://www.rubygems.org/read/chapter/7 to number its releases. This *major.minor.patch* numbering policy "is summarized":http://ablog.apress.com/?p=738 as follows.

    | Version number components: |_. Major |_. Minor |_. Patch |
    |_. Backwards compatible?    | no      | yes     | yes     |
    |_. New features?            | yes     | yes     | no      |
    |_. Bug fixes?               | yes     | yes     | yes     |
  <% end %>
<% end %>

<% chapter "Usage" do %>
  <% section "Concepts" do %>
    If you wish to wield the power of Rumai more effectively, you should understand the following basic concepts:
    * A *client* is any graphical program that is running in your X session.  In other words, any *window* in your wmii session is a *client*.
    * A *tag* is an arbitrary string (a label) that can be associated with one or more clients.
    * A *view* is a graphical representation of a *tag*.  It shows all clients associated with a particular tag.
    * An *area* is a region inside a *view*. It contains clients.
    ** A *managed area* or *column* is a region where clients cannot overlap each other.
    ** The *floating area* is an area whose clients (1) can overlap each other and (2) _float above_ the managed areas.
  <% end %>

  <% section "Interactive shell", 'shell' do %>
    Run the following command to start Rumai's interactive shell (IRB):

      rumai

    You should now see a command prompt like this:

      irb(Rumai):001:0>

    The "irb(*Rumai*)" token in the prompt indicates that commands will be evaluated _inside_ the @Rumai@ module.  As a result, you can omit the "Rumai" prefix from your commands if you wish.

    For example, to get the current client object, you can type @curr_client@ instead of having to type @Rumai.curr_client@ at the prompt.  However, note that both commands both achieve the same effect and are thereby equivalent.

    The next thing to note is that *tab completion* is enabled by default. Consequently, you can type part of a command and press the TAB key to see a list of possible completions.

    Finally, the interactive shell is a standard IRB session.  As a result your <tt>~/.irbrc</tt> file is read and processed by default.  Furthermore, you can pass the standard IRB command-line options to the *rumai* command.

    <% section "Live demonstration" do %>
      Now that you have a command prompt, let us walk through a quick demonstration that highlights the main features of Rumai.  You can follow along by copying & pasting the presented commands into the interactive shell.

      <%
        open_terms = %q{
          Launch a few terminals so that we have something to work with:
          <code>
          colors = %w[ red green blue black orange brown gray navy gold ]
          colors.each {|c| system "xterm -bg #{c} -title #{c} -e read &" }
          </code>
        }.gsub(/^\s+/, '')

        close_terms = %q{
          Close the terminals we launched earlier:
          <code>
          terms = curr_view.clients.select {|c| colors.include? c.label.read }
          terms.each {|c| c.kill }
          </code>
        }.gsub(/^\s+/, '')
      %>

      <% section "Automated client arrangement" do %>
        <%= open_terms %>

        Arrange all clients in a grid:
        <code>
        curr_view.arrange_in_grid
        </code>

        Arrange all clients in a diamond shape:
        <code>
        curr_view.arrange_in_diamond
        </code>

        Arrange all clients like LarsWM does:
        <code>
        curr_view.arrange_as_larswm
        </code>

        <%= close_terms %>
      <% end %>

      <% section "Multiple client grouping" do %>
        <%= open_terms %>

        Add the red, green, and blue terminals into the "grouping":
        <code>
        terms = curr_view.clients.select {|c| %w[red green blue].include? c.label.read }
        terms.each {|c| c.group }
        </code>

        You should now see a new button labelled as "<notextile>@</notextile>" on the left-hand side of wmii's bar, indicating that there is now a new view labelled "<notextile>@</notextile>" in wmii. Let us inspect what clients this mysterious view contains:
        <code>
        v = View.new "@"
        puts v.clients.map {|c| c.label.read }
        </code>

        Aha! The mysterious view contains the red, green, and blue clients we recently "grouped". Thus, by adding a client to the "grouping", we are simply tagging the client with the "@" token.

        Now that we have put some clients into the "grouping", let us move all clients in the grouping to the floating area in the current view:
        <code>
        grouping.each {|c| c.send "toggle" }
        </code>

        Neat! Let us bring them back into the managed area:
        <code>
        grouping.each {|c| c.send "toggle" }
        </code>

        <%= close_terms %>

        In summary, you can select multiple clients (by adding them to the "grouping") and perform operations on them. This is useful when you want to do something with a group of clients but do not want to manually focus one, perform the action, focus the next one, and so on.

        Another important aspect is that selected clients stay selected until they are unselected. This allows you to continue performing tasks on the selection without having to reselect the same clients after every operation.
      <% end %>

      <% section "Easy column manipulation" do %>
        <%= open_terms %>

        You can insert a group of clients to the top, bottom, or after the currently focused client of _any_ column using Array-like methods.

        Give each client its own column (one client per column):
        <code>
        curr_view.each_column {|c| c.length = 1 }
        </code>

        Put (at most) three clients in every column:
        <code>
        curr_view.each_column {|c| c.length = 3 }
        </code>

        Move the red, green, and blue clients into the floating area:
        <code>
        terms = curr_view.clients.select {|c| %w[red green blue].include? c.label.read }
        curr_view.areas[0].push terms
        </code>

        Slurp all floating clients into the last column:
        <code>
        list = curr_view.areas
        a, b = list.first, list.last
        b.concat a
        </code>

        Set the last column's layout to stacking mode:
        <code>
        b.layout = 'stack'
        </code>

        Move the red, green, and blue clients to the top of the second column:
        <code>
        curr_view.areas[2].unshift terms
        </code>

        Move the red, green, and blue clients to the bottom of the third column:
        <code>
        curr_view.areas[3].push terms
        </code>

        <%= close_terms %>
      <% end %>

      <% section "Easy client manipulation" do %>
        <%= open_terms %>

        Obtain a reference to the red client:
        <code>
        red = curr_view.clients.find {|c| c.label.read == "red" }
        </code>

        Show the red client's current tags:
        <code>
        red.tags
        </code>

        Add the "foo" and "bar" tags to the red client:
        <code>
        red.tag "foo", "bar"
        </code>

        Remove the "bar" tag from the red client:
        <code>
        red.untag "bar"
        </code>

        Do complex operations on the red client's tags:
        <code>
        red.with_tags { concat %w[a b c]; push 'z'; delete 'c' }
        </code>

        Focus the next client after the red client:
        <code>
        red.next.focus ; curr_client == red.next #=> true
        </code>

        Notice that by focusing a client, we make it the current client.

        Focus the red client on a different view:
        <code>
        orig = curr_view
        v = red.views.last
        red.focus v
        </code>

        Return to the original view:
        <code>
        orig.focus
        </code>

        Send the red client to the last column:
        <code>
        red.send curr_view.areas.last
        </code>

        <%= close_terms %>
      <% end %>

      <% section "Traversing the file system" do %>
        Show the root node of wmii's IXP file system:
        <code>
        fs
        </code>

        Show the names of all files at the root level:
        <code>
        fs.entries
        </code>

        Show the parent of the root node:
        <code>
        fs.parent
        </code>

        Show the children of the root node:
        <code>
        fs.children
        </code>

        Navigate into to the <tt>/lbar/</tt> directory:
        <code>
        n1 = fs.lbar
        n2 = fs['lbar']
        n1 == n2 #=> true
        left_bar = n1
        </code>

        Notice that you can traverse the file system hierarchy by simply calling methods on node objects.  Alternatively, you can traverse by specifying an arbitrary sub-path (relative path) using the @[]@ operator on a node.

        Create a new temporary button:
        <code>
        b = left_bar.rumai_example # path of new button
        b.exist? #=> false
        b.create
        b.exist? #=> true
        </code>

        You should now see an empty button on the left-hand side of the wmii bar.

        Color the button black-on-white and label it as "hello world":
        <code>
        content = "#000000 #ffffff #000000 hello world"
        b.write content
        b.read == content #=> true
        </code>

        Remove the temporary button:
        <code>
        b.remove
        b.exist? #=> false
        </code>
      <% end %>
    <% end %>

    <% section "Available commands" do %>
      The following table lists all methods provided by the @Rumai@ module and its subordinates.  See the "API documentation":api/index.html for more extensive documentation.

      |_. Method declaration |_. Description |
      <%
        # load library for parsing method documentation
        require 'gerbil/rdoc'

        Dir['lib/rumai/*.rb'].each do |f|
          RDoc::TopLevel.parse_file f
        end

        RDoc::TopLevel.all_methods.sort_by {|m| m.full_name }.each do |m|
      %>
      | <code><%= m.decl %></code> | <noformat><%= m.comment_html %></noformat> |
      <% end %>
    <% end %>
  <% end %>

  <% section "Scripting your wmiirc", 'wmiirc' do %>
    One important application of Rumai is the support of Ruby-based <tt>wmiirc</tt> configuration files. For a solid example of such application, take a look at my personal <tt>wmiirc</tt> which uses Rumai extensively:

      darcs get http://snk.tuxfamily.org/src/wmiirc

    Alternatively, you can "browse the contents of the above repository":http://snk.tuxfamily.org/src/wmiirc in your web browser.
  <% end %>
<% end %>
